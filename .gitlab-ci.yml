include:
  - template: "Workflows/Branch-Pipelines.gitlab-ci.yml"
  - project: "IONDEV/tacklebox"
    file: "gitlab_ci_templates/pre-commit.yml"

variables:
  PYTHON_DOCKER_IMAGE: python:3.7-buster
  GIT_SUBMODULE_STRATEGY: recursive
  GUPPY_VERSION: 7.2.13
  PYGUPPY_INSTALL: ont-pybasecall-client-lib==${GUPPY_VERSION}
  GUPPY_ARCHIVE: ${ARTIFACTORY_URL}/artifactory/OFAN-General/release/${GUPPY_VERSION}/ont-dorado-server_${GUPPY_VERSION}_linux64.tar.gz
  ONT_PYPI: "--extra-index-url ${ARTIFACTORY_URL}/artifactory/api/pypi/ONTDev-Pypi/simple --extra-index-url ${ARTIFACTORY_URL}/artifactory/api/pypi/ONT-Pypi/simple --trusted-host ${ARTIFACTORY_HOST}"

stages:
  - check
  - package
  - package_test
  - deploy

check.version:
  stage: check
  image: ${PYTHON_DOCKER_IMAGE}
  script:
    - pip install ${ONT_PYPI} -r requirements.txt
    - python setup.py install
    - ru_version=$( python -c "import read_until; print(read_until.__version__)" 2>&1 )
    - tag_version="${CI_BUILD_REF_NAME/#v/}"
    - if [[ "${ru_version}" != "${tag_version}" ]]; then
        echo "Tag is for release ${tag_version}, but read_until version is $ru_version";
        exit 1;
      fi
  only: ["tags"]

check.pre-commit:
  extends: .tacklebox pre-commit
  stage: check

check.pylint:
  stage: check
  image: ${PYTHON_DOCKER_IMAGE}
  script:
    # TODO: integrate this with pre-commit (after fixing all the issues)
    - pip install ${ONT_PYPI} -r requirements.txt
    - pip install -r dev-requirements.txt
    - python setup.py install
    - ignore_pattern=".*pb2.*"
    - pylint --ignore-patterns="${ignore_pattern}" read_until || true
    - echo "pylint_score $(pylint --ignore-patterns="${ignore_pattern}" ./read_until | tail -2 | grep -o -E '[0-9.]+' | head -1)" >metrics.txt
    - cat metrics.txt
  artifacts:
    reports:
      metrics: metrics.txt

check.docs:
  stage: check
  image: ${PYTHON_DOCKER_IMAGE}
  script:
    - pip install ${ONT_PYPI} -r requirements.txt
    - pip install ${ONT_PYPI} ${PYGUPPY_INSTALL}
    - pip install -r dev-requirements.txt
    - python setup.py install
    - sphinx-build -b html docs/ public
  artifacts:
    paths:
      - public

.test_skeleton: &test_skeleton
  stage: check
  image: ${PYTHON_DOCKER_IMAGE}
  script:
    - pip install ${ONT_PYPI} -r requirements.txt
    - pip install -r dev-requirements.txt
    - python setup.py develop
    - pytest --cov=read_until --cov-report html:cov_html --cov-report term --junitxml=./junit.xml test/test_*.py
  artifacts:
    reports:
      junit: ./junit.xml
    paths:
      - cov_html/

check.test.python38:
  <<: *test_skeleton
  image: python:3.8-buster

check.test.python37:
  <<: *test_skeleton
  image: python:3.7-buster

test_id_example:
  stage: check
  image: ${PYTHON_DOCKER_IMAGE}
  script:
    - if [ ! -z ${GUPPY_ARCHIVE} ]; then
        curl -kL ${GUPPY_ARCHIVE} > guppy.tar.gz;
        tar -xf guppy.tar.gz;
        export PATH=${PWD}/ont-guppy-cpu/bin:${PWD}/ont-guppy/bin:$PATH;
      fi
    - pip install ${ONT_PYPI} -r requirements.txt
    - pip install ${ONT_PYPI} ${PYGUPPY_INSTALL}
    - pip install -r dev-requirements.txt
    - python setup.py develop
    - pytest --cov=read_until --cov-report html:cov_html --cov-report term --junitxml=./junit.xml
        test/test_identification
  artifacts:
    reports:
      junit: ./junit.xml
    paths:
      - cov_html/
  allow_failure: false


build_wheel:
  stage: package
  image: ${PYTHON_DOCKER_IMAGE}
  script:
    - pip install ${ONT_PYPI} -r requirements.txt
    - python setup.py bdist_wheel
  artifacts:
    paths:
      - dist/

install_wheel:
  stage: package_test
  image: ${PYTHON_DOCKER_IMAGE}
  dependencies: ["build_wheel"]
  script:
    - pip install ${ONT_PYPI} -r requirements.txt

wheel upload:
  stage: deploy
  image: ${UPLOAD_PYTHON_IMAGE}
  dependencies: ["build_wheel"]
  script:
      - ls dist/
      - pip install twine
      - twine upload ./dist/*.*
  only: ["tags"]

# the mirror to GitHub jobs require the following CI environment variables:
# * GITHUB_SSH_PRIVATE_KEY_FILE (a file-type variable)
# * GITHUB_USER_EMAIL
# * GITHUB_USER_NAME
# * GITHUB_HOST_KEY
# * GITHUB_REMOTE

mirror to GitHub (dry-run):
  stage: deploy
  image: ${CI_REGISTRY}/traque/ont-docker-base/ont-base-ubuntu:20.04
  needs: []
  rules:
    - when: manual
  before_script:
    # install git
    - apt-get update > /dev/null
    - apt-get install --yes --no-install-recommends git > /dev/null
    # setup SSH for git
    - mkdir -p ~/.ssh
    - echo ${GITHUB_HOST_KEY} >> ~/.ssh/known_hosts
    - eval $(ssh-agent -s)
    - chmod 400 "${GITHUB_SSH_PRIVATE_KEY_FILE}"  # required for ssh-add
    - ssh-add "${GITHUB_SSH_PRIVATE_KEY_FILE}"
    # setup git identity
    - git config --global user.email "${GITHUB_USER_EMAIL}"
    - git config --global user.name "${GITHUB_USER_NAME}"
  script:
    - git fetch --unshallow
    - tacklebox/bin/git_mirror "${GITHUB_REMOTE}" --verbose --branch "dev" --tag-regex "v.+" --dry-run
  variables:
    GITHUB_HOST_KEY: "[ssh.github.com]:443 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOMqqnkVzrm0SdG6UOoqKLsabgH5C9okWi0dh2l9GKJl"
    # note: we're doing SSH over port 443 to avoid firewall rules
    GITHUB_REMOTE: "ssh://git@ssh.github.com:443/nanoporetech/read_until_api.git"

mirror to GitHub:
  extends: mirror to GitHub (dry-run)
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
  script:
    # this should be identical to the job above, but without the `--dry-run` argument
    - git fetch --unshallow
    - tacklebox/bin/git_mirror "${GITHUB_REMOTE}" --verbose --branch "dev" --tag-regex "v.+"
